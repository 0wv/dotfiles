#!/usr/bin/env bash

set -eu

PROG_NAME="$(basename "$0")"
all=false
dirs=()
dry=
mode=ln
profile=archlinux

function main {
  cd "$(dirname "$0")"

  while getopts ad:hm:np: opt; do
    case "$opt" in
      a )
        all=true
        ;;

      d )
        dirs+=("$OPTARG")
        ;;

      h )
        get_help
        exit 0
        ;;

      m )
        mode="$OPTARG"
        ;;

      n )
        dry='echo -e \e[1;36mDry:\e[m'
        ;;

      p )
        profile="$OPTARG"
        ;;
    esac
  done

  if [[ $all = false ]]; then
    if [[ ${#dirs[@]} -lt 1 ]]; then
      error 'there is nothing to do'
      get_help
      return 3
    fi

    for ((i = 0; i < ${#dirs[@]}; i++)); do
      dir="${dirs[i]}"

      if [[ -d $dir ]]; then
        continue
      elif [[ -d $dir.$profile ]]; then
        dirs[i]="$dir.$profile"
        continue
      fi

      error 'not found:' "$dir"
      return 4
    done
  fi

  if [[ $all = false ]]; then
    for dir in "${dirs[@]}"; do
      git ls-files -z "$dir"
    done
  else
    find -maxdepth 1 -mindepth 1 -type d -print0 | while IFS= read -rd $'\0' dir; do
      if grep -q ".$profile$" <<< "$dir"; then
        printf '%s\0' "$dir"
      fi
    done | xargs -0 git ls-files -z
  fi | while IFS= read -rd $'\0' file; do
    if grep -q '/.gitkeep$' <<< "$file"; then
      dir="$(dirname "$file")"
      relative_path="${dir#*/}"
      target_dir="$HOME/$relative_path"

      if [[ ! -d $target_dir ]]; then
        $dry mkdir -pv "$target_dir"
      fi

      continue
    fi

    relative_path="${file#*/}"
    out_file="$HOME/$relative_path"
    parent_dir="$(dirname "$out_file")"
    src_file="$PWD/$file"

    case "$mode" in
      ln )
        if [[ ! -d $parent_dir ]]; then
          $dry mkdir -pv "$parent_dir"
        fi

        if [[ -z $dry ]] && [[ "$(realpath "$out_file")" = "$(realpath "$src_file")" ]]; then
          info 'already linked... skipping:' "$src_file"
          continue
        elif [[ -e $out_file ]]; then
          warn 'skipping to avoid overwriting:' "$src_file"
          continue
        fi

        $dry ln -sv "$src_file" "$out_file"
        ;;

      rm )
        if [[ "$(realpath "$out_file")" != "$(realpath "$src_file")" ]]; then
          info 'not linked... skipping:' "$src_file"
          continue
        fi

        $dry rm -v "$out_file"
        $dry recursive_rmdir "$(dirname "$out_file")"
        ;;

      * )
        error 'invalid mode:' "$mode"
        return 5
        ;;
    esac
  done
}

function recursive_rmdir {
  local dir="$1"

  if [[ -d "$dir" ]]; then
    rmdir -v "$dir" 2> /dev/null || return
    recursive_rmdir "$(dirname "$dir")"
  else
    error 'not a directory:' "$dir"
    return 3
  fi
}

function error {
  printf '\e[1;31mError:\e[m %s\n' "$*"
}

function get_help {
  cat << /cat

Usage:
  $PROG_NAME [options]

Options:
  -a            mark all dirs
  -d <dir>      mark the dir
  -m <ln|rm>    set the mode [default: ln]
  -n            perform a trial run with no changes made
  -p <profile>  set the profile name [default: archlinux]

  -h            display this help
/cat
}

function info {
  printf '\e[1;32mInfo:\e[m %s\n' "$*"
}

function warn {
  printf '\e[1;33mWarn:\e[m %s\n' "$*"
}

main "$@"
